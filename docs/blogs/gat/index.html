<!DOCTYPE html>
<html lang="en-us"><head>
  <!-- Basic Page Needs -->
  <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  
  <meta name="description" content="Machine Learning / Graph Representation Learning">
  <meta name="author" content="DSG">
  <meta name="generator" content="Hugo 0.61.0" />
  
  <!-- Mobile Specific Metas -->
  <meta name="format-detection" content="telephone=no">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Understanding Graph Attention Networks (GAT)</title>
  <link rel="icon" href="/images/dsg.ico">

  <!-- Twitter Bootstrs CSS -->
  <link rel="stylesheet" href="/plugins/bootstrap/bootstrap.min.css">
  <!-- Ionicons Fonts Css -->
  <link rel="stylesheet" href="/plugins/ionicons/ionicons.min.css">
  <!-- animate css -->
  <link rel="stylesheet" href="/plugins/animate-css/animate.css">
  <!-- Hero area slider css-->
  <link rel="stylesheet" href="/plugins/slider/slider.css">
  <!-- slick slider -->
  <link rel="stylesheet" href="/plugins/slick/slick.css">
  <!-- Fancybox -->
  <link rel="stylesheet" href="/plugins/facncybox/jquery.fancybox.css">
  <!-- hover -->
  <link rel="stylesheet" href="/plugins/hover/hover-min.css">
  <!-- template main css file -->
  
  <link rel="stylesheet" href="/css/style.min.css" integrity="" media="screen">
</head><body><section class="top-bar animated-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-12">
                <nav class="navbar navbar-expand-lg navbar-light bg-light">
                    <a class="navbar-brand" href="/">
                        <img id="logo" src="/images/dsg.png" alt="logo">
                        <span class="logoText">DSG</span>
                    </a>
                    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navigation"
                        aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>

                    <div class="collapse navbar-collapse" id="navigation">
                        <ul class="navbar-nav ml-auto">
                            <li class="nav-item">
                                <a class="nav-link"
                                    href="/">Home
                                </a>
                            </li>
                            
                            <li class="nav-item">
                                
                                    <a class="nav-link" href="/#works">Work</a>
                                
                                
                                
                            </li>
                            
                            <li class="nav-item">
                                
                                
                                    <a class="nav-link" href="/events">Events</a>
                                
                                
                            </li>
                            
                            <li class="nav-item">
                                
                                
                                    <a class="nav-link" href="/blogs">Blogs</a>
                                
                                
                            </li>
                            
                            <li class="nav-item">
                                
                                
                                    <a class="nav-link" href="/about">About</a>
                                
                                
                            </li>
                            
                    </div>
                </nav>
            </div>
        </div>
    </div>
</section>

<section class="global-page-header">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2>Understanding Graph Attention Networks (GAT)</h2>
                    <div class="portfolio-meta">
                        <span>Wednesday, Jan 1, 2020</span>|
                        <span> Tags:
                            Graph Representation Learning
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="single-post">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                
                <div class="post-img">
                    <img class="img-fluid-work" alt="" src="/images/blogs/GAT/GAT_Cover.jpg">
                </div>
                
                <div class="post-content">
                    <!-- # Understanding Graph Attention Networks (GAT) -->
<h1><center>Understanding Graph Attention Networks (GAT)</center></h1>
<!-- ![GAT Cover](GAT_Cover.jpg) -->
<!-- <img src="images/blogs/GAT/GAT_Cover.jpg" width=700x/> -->
<p>This is 4th in the series of blogs <font color="green"><b>Explained: Graph Representation Learning</b></font>. Let's dive right in, assuming you have read the first three. GAT (Graph Attention Network), is a novel neural network architecture that operate on graph-structured data, leveraging masked self-attentional layers to address the shortcomings of prior methods based on graph convolutions or their approximations. By stacking layers in which nodes are able to attend over their neighborhoods’ features, the method enables (implicitly) specifying different weights to different nodes in a neighborhood, without requiring any kind of costly matrix operation (such as inversion) or depending on knowing the graph structure upfront. In this way, GAT addresses several key challenges of spectral-based graph neural networks simultaneously, and make the model readily applicable to inductive as well as transductive problems.</p>
<p>Analyzing and Visualizing the learned attentional weights also lead to a more interpretable model in terms of importance of neighbors.</p>
<p>But before getting into the meat of this method, I want you to be familiar and thorough with the Attention Mechanism, because we'll be building GATs on the concept of <b>Self Attention</b> and <b>Multi-Head Attention</b> introduced by <b><i>Vaswani et al.</i></b>
If not, you may read this blog, <a href="http://jalammar.github.io/illustrated-transformer/">The Illustrated Transformer</a> by Jay Alamar.</p>
<hr/>
<h1><center>Can we do better than GCNs?</center></h1>
<p>From Graph Convolutional Network (GCN), we learnt that combining local graph structure and node-level features yields good performance on node classification task. However, the way GCN aggregates messages is <b>structure-dependent</b>, which may hurt its generalizability.</p>
<p>The fundamental novelty that GAT brings to the table is how the information from the one-hop neighborhood is aggregated. For GCN, a graph convolution operation produces the normalized sum of neighbors&rsquo; node features as follows:</p>
<p>$$h_i^{(l+1)}=\sigma\left(\sum_{j\in \mathcal{N}(i)} {\frac{1}{c_{ij}} W^{(l)}h^{(l)}_j}\right)$$</p>
<p>where $\mathcal{N}(i)$ is the set of its one-hop neighbors (to include $v_{i}$ in the set, we simply added a self-loop to each node), $c_{ij}=\sqrt{|\mathcal{N}(i)|}\sqrt{|\mathcal{N}(j)|}$ is a normalization constant based on graph structure, $\sigma$ is an activation function (GCN uses ReLU), and $W^{l}$ is a shared weight matrix for node-wise feature transformation.</p>
<p>GAT introduces the attention mechanism as a substitute for the statically normalized convolution operation. The figure below clearly illustrates the key difference.</p>
<!-- <figure class="floatcenter">
    <img src="/images/blogs/GAT/GCN_vs_GAT.jpg" width="800x"/> <figcaption>
            <h4>GCN vs GAT</h4>
        </figcaption>
</figure>
 -->
<center><strong>GCN vs GAT</strong></center>
<img src="/images/blogs/GAT/GCN_vs_GAT.jpg" width=800x/>
<hr/>
<!-- ## How does the attention work in GAT layer? -->
<h1><center>How does the GAT layer work?</center></h1>
<p>The particular attentional setup utilized by GAT closely follows the work of <code>Bahdanau et al. (2015)</code> i.e <i>Additive Attention</i>, but the framework is agnostic to the particular choice of attention mechanism.</p>
<p>The input to the layer is a set of node features, $\mathbf{h} = {\vec{h}_1,\vec{h}_2,&hellip;,\vec{h}_N}, \vec{h}_i ∈ \mathbb{R}^{F}$ , where $N$ is the
number of nodes, and $F$ is the number of features in each node. The layer produces a new set of node
features (of potentially different cardinality $F'$ ), $\mathbf{h} = {\vec{h&rsquo;}_1,\vec{h&rsquo;}_2,&hellip;,\vec{h&rsquo;}_N}, \vec{h&rsquo;}_i ∈ \mathbb{R}^{F&rsquo;}$, as its output.</p>
<h3><font color="black" >The Attentional Layer broken into 4 separate parts:</font></h3>
<hr/>
<p><strong>1) <font color="red">Simple linear transformation:</font></strong> In order to obtain sufficient expressive power to transform the input features into higher level features, atleast one learnable linear transformation is required. To that end, as an initial step, a shared linear transformation, parametrized by a weight matrix, $W ∈ \mathbb{R}^{F′×F}$ , is applied to every node.</p>
<p>$$\begin{split}\begin{align}
z_i^{(l)}&amp;=W^{(l)}h_i^{(l)} \<br>
\end{align}\end{split}$$</p>
<img style="float: right;" src="/images/blogs/GAT/Attentional_Layer.jpg" width=400x/>
<hr/>
<span>
<strong>2) <font color="red">Attention Coefficients:</font> We then compute a pair-wise <font color="blue">un-normalized</font></strong>
</span> attention score between two neighbors. Here, it first concatenates the $z$ embeddings of the two nodes, where $||$ denotes concatenation, then takes a dot product of it with a learnable weight vector $\vec a^{(l)}$, and applies a LeakyReLU in the end. This form of attention is usually called additive attention, in contrast with the dot-product attention used for the Transformer model. We then perform self-attention on the nodes, a shared attentional mechanism $a$ : $\mathbb{R}^{F′} × \mathbb{R}^{F′} → \mathbb{R}$ to compute attention coefficients 
$$\begin{split}\begin{align}
e_{ij}^{(l)}&=\text{LeakyReLU}(\vec a^{(l)^T}(z_i^{(l)}||z_j^{(l)}))\\
\end{align}\end{split}$$
<p><strong>Q. Is this step the most important step?</strong></p>
<p><strong>Ans.</strong> Yes! This indicates the importance of node $j’s$ features to node $i$. This step allows every node to attend on every other node, dropping all structural information.</p>
<p><strong>NOTE:</strong> The graph structure is injected into the mechanism by performing <b><em>masked attention</em></b>, we only compute $e_{ij}$ for nodes $j$ ∈ $N_{i}$, where $N_{i}$ is some neighborhood of node $i$ in the graph. In all the experiments, these will be exactly the first-order neighbors of $i$ (including $i$).</p>
<hr/>
<p><strong>3) <font color="red">Softmax:</font></strong> This makes coefficients easily comparable across different nodes, we normalize them across all choices of $j$ using the softmax function</p>
<p>$$\begin{split}\begin{align}
\alpha_{ij}^{(l)}&amp;=\frac{\exp(e_{ij}^{(l)})}{\sum_{k\in \mathcal{N}(i)}^{}\exp(e_{ik}^{(l)})}\<br>
\end{align}\end{split}$$</p>
<hr/>
<p><strong>4) <font color="red">Aggregation:</font></strong> This step is similar to GCN. The embeddings from neighbors are aggregated together, scaled by the attention scores.</p>
<p>$$\begin{split}\begin{align}
h_i^{(l+1)}&amp;=\sigma\left(\sum_{j\in \mathcal{N}(i)} {\alpha^{(l)}_{ij} z^{(l)}_j }\right)
\end{align}\end{split}$$</p>
<hr/>
<!-- ![Attentional Layer](Attentional_Layer.jpg){:style="float: right;margin-right: 7px;margin-top: 7px;"} -->
<!-- ![Attentional Layer](Attentional_Layer.jpg =250x) -->
<!-- ### Multi-head Attention -->
<h2><center>Multi-head Attention</center></h2>
<figure>
  <img style="float: right; width: 70%" src="/images/blogs/GAT/MultiHead_Attention.jpeg">
  <figcaption>An illustration of multi-head attention (with K = 3 heads) by node 1 on its neighborhood. Different arrow styles and colors denote independent attention computations. The aggregated features from each head are concatenated or averaged to obtain $\vec{h'}_{1}$.</figcaption>
</figure>
<p><br clear=”both” /></p>
<p>Analogous to multiple channels in a Convolutional Net, GAT uses multi-head attention to enrich the model capacity and to stabilize the learning process. Specifically, K independent attention mechanisms execute the transformation of Equation 4, and then their outputs can be combined in 2 ways depending on the use:</p>
<p>$$\textbf{$ \color{red}{Average} $}: h_{i}^{(l+1)}=\sigma\left(\frac{1}{K}\sum_{k=1}^{K}\sum_{j\in\mathcal{N}(i)}\alpha_{ij}^{k}W^{k}h^{(l)}_{j}\right)$$
$$\textbf{$ \color{green}{Concatenation} $}: h^{(l+1)}_{i}=||_{k=1}^{K}\sigma\left(\sum_{j\in \mathcal{N}(i)}\alpha_{ij}^{k}W^{k}h^{(l)}_{j}\right)$$</p>
<p><b>1) <font color="green">Concatenation</font></b>
As can be seen in this setting, the final returned output, $h′$, will consist of $KF′$ features (rather than F′) for each node.</p>
<p><b>2) <font color="red">Averaging</font></b></p>
<p>If we perform multi-head attention on the final (prediction) layer of the network, concatenation is no longer sensible and instead, averaging is employed, and delay applying the final nonlinearity (usually a softmax or logistic sigmoid for classification problems).</p>
<p><b>Thus <font color="green">concatenation for intermediary layers</font> and <font color="red">average for the final layer</font> are used.</b></p>
<hr/>
<!-- ## Implementing GAT Layer in PyTorch -->
<h1><center>Implementing GAT Layer in PyTorch</center></h1>
<h2 id="imports">Imports</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">
<span style="color:#f92672">import</span> numpy <span style="color:#f92672">as</span> np
<span style="color:#f92672">import</span> torch
<span style="color:#f92672">import</span> torch.nn <span style="color:#f92672">as</span> nn
<span style="color:#f92672">import</span> torch.nn.functional <span style="color:#f92672">as</span> F

torch<span style="color:#f92672">.</span>manual_seed(<span style="color:#ae81ff">2020</span>) <span style="color:#75715e"># seed for reproducible numbers</span>
</code></pre></div><h2 id="gat-layer">GAT Layer</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GATLayer</span>(nn<span style="color:#f92672">.</span>Module):
    <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;&#34;&#34;</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">    Simple PyTorch Implementation of the Graph Attention layer.</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">    </span><span style="color:#e6db74">&#34;&#34;&#34;</span>

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__init__</span>(self, in_features, out_features, dropout, alpha, concat<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>):
        super(GATLayer, self)<span style="color:#f92672">.</span>__init__()
        self<span style="color:#f92672">.</span>dropout       <span style="color:#f92672">=</span> dropout        <span style="color:#75715e"># drop prob = 0.6</span>
        self<span style="color:#f92672">.</span>in_features   <span style="color:#f92672">=</span> in_features    <span style="color:#75715e"># </span>
        self<span style="color:#f92672">.</span>out_features  <span style="color:#f92672">=</span> out_features   <span style="color:#75715e"># </span>
        self<span style="color:#f92672">.</span>alpha         <span style="color:#f92672">=</span> alpha          <span style="color:#75715e"># LeakyReLU with negative input slope, alpha = 0.2</span>
        self<span style="color:#f92672">.</span>concat        <span style="color:#f92672">=</span> concat         <span style="color:#75715e"># conacat = True for all layers except the output layer.</span>

        <span style="color:#75715e"># Xavier Initialization of Weights</span>
        <span style="color:#75715e"># Alternatively use weights_init to apply weights of choice </span>
        self<span style="color:#f92672">.</span>W <span style="color:#f92672">=</span> nn<span style="color:#f92672">.</span>Parameter(torch<span style="color:#f92672">.</span>zeros(size<span style="color:#f92672">=</span>(in_features, out_features)))
        nn<span style="color:#f92672">.</span>init<span style="color:#f92672">.</span>xavier_uniform_(self<span style="color:#f92672">.</span>W<span style="color:#f92672">.</span>data, gain<span style="color:#f92672">=</span><span style="color:#ae81ff">1.414</span>)
        self<span style="color:#f92672">.</span>a <span style="color:#f92672">=</span> nn<span style="color:#f92672">.</span>Parameter(torch<span style="color:#f92672">.</span>zeros(size<span style="color:#f92672">=</span>(<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>out_features, <span style="color:#ae81ff">1</span>)))
        nn<span style="color:#f92672">.</span>init<span style="color:#f92672">.</span>xavier_uniform_(self<span style="color:#f92672">.</span>a<span style="color:#f92672">.</span>data, gain<span style="color:#f92672">=</span><span style="color:#ae81ff">1.414</span>)
        
        <span style="color:#75715e"># LeakyReLU</span>
        self<span style="color:#f92672">.</span>leakyrelu <span style="color:#f92672">=</span> nn<span style="color:#f92672">.</span>LeakyReLU(self<span style="color:#f92672">.</span>alpha)

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">forward</span>(self, input, adj):
        <span style="color:#75715e"># Linear Transformation</span>
        h <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>mm(input, self<span style="color:#f92672">.</span>W)
        N <span style="color:#f92672">=</span> h<span style="color:#f92672">.</span>size()[<span style="color:#ae81ff">0</span>]

        <span style="color:#75715e"># Attention Mechanism</span>
        a_input <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>cat([h<span style="color:#f92672">.</span>repeat(<span style="color:#ae81ff">1</span>, N)<span style="color:#f92672">.</span>view(N <span style="color:#f92672">*</span> N, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>), h<span style="color:#f92672">.</span>repeat(N, <span style="color:#ae81ff">1</span>)], dim<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">.</span>view(N, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> self<span style="color:#f92672">.</span>out_features)
        e       <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>leakyrelu(torch<span style="color:#f92672">.</span>matmul(a_input, self<span style="color:#f92672">.</span>a)<span style="color:#f92672">.</span>squeeze(<span style="color:#ae81ff">2</span>))

        <span style="color:#75715e"># Masked Attention</span>
        zero_vec  <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">9e15</span><span style="color:#f92672">*</span>torch<span style="color:#f92672">.</span>ones_like(e)
        attention <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>where(adj <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>, e, zero_vec)
        
        attention <span style="color:#f92672">=</span> F<span style="color:#f92672">.</span>softmax(attention, dim<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
        attention <span style="color:#f92672">=</span> F<span style="color:#f92672">.</span>dropout(attention, self<span style="color:#f92672">.</span>dropout, training<span style="color:#f92672">=</span>self<span style="color:#f92672">.</span>training)
        h_prime   <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>matmul(attention, h)

        <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>concat:
            <span style="color:#66d9ef">return</span> F<span style="color:#f92672">.</span>elu(h_prime)
        <span style="color:#66d9ef">else</span>:
            <span style="color:#66d9ef">return</span> h_prime</code></pre></div>
<!-- ## Implementing GAT on Citation Datasets using PyTorch Geometric -->
<h1><center>Implementing GAT on Citation Datasets using PyTorch Geometric</center></h1>
<h3 id="pyg-imports">PyG Imports</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> torch_geometric.data <span style="color:#f92672">import</span> Data
<span style="color:#f92672">from</span> torch_geometric.nn <span style="color:#f92672">import</span> GATConv
<span style="color:#f92672">from</span> torch_geometric.datasets <span style="color:#f92672">import</span> Planetoid
<span style="color:#f92672">import</span> torch_geometric.transforms <span style="color:#f92672">as</span> T

<span style="color:#f92672">import</span> matplotlib.pyplot <span style="color:#f92672">as</span> plt
<span style="color:#f92672">%</span>matplotlib notebook

<span style="color:#f92672">import</span> warnings
warnings<span style="color:#f92672">.</span>filterwarnings(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">ignore</span><span style="color:#e6db74">&#34;</span>)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">name_data <span style="color:#f92672">=</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">Cora</span><span style="color:#e6db74">&#39;</span>
dataset <span style="color:#f92672">=</span> Planetoid(root<span style="color:#f92672">=</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">/tmp/</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">+</span> name_data, name <span style="color:#f92672">=</span> name_data)
dataset<span style="color:#f92672">.</span>transform <span style="color:#f92672">=</span> T<span style="color:#f92672">.</span>NormalizeFeatures()

<span style="color:#66d9ef">print</span>(f<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Number of Classes in {name_data}:</span><span style="color:#e6db74">&#34;</span>, dataset<span style="color:#f92672">.</span>num_classes)
<span style="color:#66d9ef">print</span>(f<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Number of Node Features in {name_data}:</span><span style="color:#e6db74">&#34;</span>, dataset<span style="color:#f92672">.</span>num_node_features)
</code></pre></div><h3 id="model">Model</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GAT</span>(torch<span style="color:#f92672">.</span>nn<span style="color:#f92672">.</span>Module):
    <span style="color:#66d9ef">def</span> __init__(self):
        super(GAT, self)<span style="color:#f92672">.</span>__init__()
        self<span style="color:#f92672">.</span>hid <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>
        self<span style="color:#f92672">.</span>in_head <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>
        self<span style="color:#f92672">.</span>out_head <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
        
        self<span style="color:#f92672">.</span>conv1 <span style="color:#f92672">=</span> GATConv(dataset<span style="color:#f92672">.</span>num_features, self<span style="color:#f92672">.</span>hid, heads<span style="color:#f92672">=</span>self<span style="color:#f92672">.</span>in_head, dropout<span style="color:#f92672">=</span><span style="color:#ae81ff">0.6</span>)
        self<span style="color:#f92672">.</span>conv2 <span style="color:#f92672">=</span> GATConv(self<span style="color:#f92672">.</span>hid<span style="color:#f92672">*</span>self<span style="color:#f92672">.</span>in_head, dataset<span style="color:#f92672">.</span>num_classes, concat<span style="color:#f92672">=</span>False,
                             heads<span style="color:#f92672">=</span>self<span style="color:#f92672">.</span>out_head, dropout<span style="color:#f92672">=</span><span style="color:#ae81ff">0.6</span>)

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">forward</span>(self, data):
        x, edge_index <span style="color:#f92672">=</span> data<span style="color:#f92672">.</span>x, data<span style="color:#f92672">.</span>edge_index
        
        <span style="color:#75715e"># Dropout before the GAT layer is used to avoid overfitting in small datasets like Cora.</span>
        <span style="color:#75715e"># One can skip them if the dataset is sufficiently large.</span>
        
        x <span style="color:#f92672">=</span> F<span style="color:#f92672">.</span>dropout(x, p<span style="color:#f92672">=</span><span style="color:#ae81ff">0.6</span>, training<span style="color:#f92672">=</span>self<span style="color:#f92672">.</span>training)
        x <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>conv1(x, edge_index)
        x <span style="color:#f92672">=</span> F<span style="color:#f92672">.</span>elu(x)
        x <span style="color:#f92672">=</span> F<span style="color:#f92672">.</span>dropout(x, p<span style="color:#f92672">=</span><span style="color:#ae81ff">0.6</span>, training<span style="color:#f92672">=</span>self<span style="color:#f92672">.</span>training)
        x <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>conv2(x, edge_index)
        
        <span style="color:#66d9ef">return</span> F<span style="color:#f92672">.</span>log_softmax(x, dim<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</code></pre></div><h3 id="train">Train</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">device <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>device(<span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">cuda</span><span style="color:#e6db74">&#39;</span> <span style="color:#66d9ef">if</span> torch<span style="color:#f92672">.</span>cuda<span style="color:#f92672">.</span>is_available() <span style="color:#66d9ef">else</span> <span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">cpu</span><span style="color:#e6db74">&#39;</span>)

model <span style="color:#f92672">=</span> GAT()<span style="color:#f92672">.</span>to(device)

data <span style="color:#f92672">=</span> dataset[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>to(device)
optimizer <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>optim<span style="color:#f92672">.</span>Adam(model<span style="color:#f92672">.</span>parameters(), lr<span style="color:#f92672">=</span><span style="color:#ae81ff">0.005</span>, weight_decay<span style="color:#f92672">=</span><span style="color:#ae81ff">5e-4</span>)

model<span style="color:#f92672">.</span>train()
<span style="color:#66d9ef">for</span> epoch <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1000</span>):
    model<span style="color:#f92672">.</span>train()
    optimizer<span style="color:#f92672">.</span>zero_grad()
    out <span style="color:#f92672">=</span> model(data)
    loss <span style="color:#f92672">=</span> F<span style="color:#f92672">.</span>nll_loss(out[data<span style="color:#f92672">.</span>train_mask], data<span style="color:#f92672">.</span>y[data<span style="color:#f92672">.</span>train_mask])
    
    <span style="color:#66d9ef">if</span> epoch<span style="color:#f92672">%</span><span style="color:#ae81ff">200</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
        <span style="color:#66d9ef">print</span>(loss)
    
    loss<span style="color:#f92672">.</span>backward()
    optimizer<span style="color:#f92672">.</span>step()
</code></pre></div><h3 id="evaluate">Evaluate</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">model<span style="color:#f92672">.</span>eval()
_, pred <span style="color:#f92672">=</span> model(data)<span style="color:#f92672">.</span>max(dim<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
correct <span style="color:#f92672">=</span> float(pred[data<span style="color:#f92672">.</span>test_mask]<span style="color:#f92672">.</span>eq(data<span style="color:#f92672">.</span>y[data<span style="color:#f92672">.</span>test_mask])<span style="color:#f92672">.</span>sum()<span style="color:#f92672">.</span>item())
acc <span style="color:#f92672">=</span> correct <span style="color:#f92672">/</span> data<span style="color:#f92672">.</span>test_mask<span style="color:#f92672">.</span>sum()<span style="color:#f92672">.</span>item()
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">Accuracy: {:.4f}</span><span style="color:#e6db74">&#39;</span><span style="color:#f92672">.</span>format(acc))
</code></pre></div><h2 id="references">References</h2>
<p><a href="https://arxiv.org/abs/1710.10903">Graph Attention Networks</a></p>
<p><a href="https://docs.dgl.ai/tutorials/models/1_gnn/9_gat.html">Graph attention network, DGL by Zhang et al.</a></p>
<p><a href="https://arxiv.org/pdf/1706.03762.pdf">Attention Is All You Need</a></p>
<p><a href="http://jalammar.github.io/illustrated-transformer/">The Illustrated Transformer</a></p>
<p><a href="https://jalammar.github.io/visualizing-neural-machine-translation-mechanics-of-seq2seq-models-with-attention/">Mechanics of Seq2seq Models With Attention</a></p>
<p><a href="https://lilianweng.github.io/lil-log/2018/06/24/attention-attention.html">Attention? Attention!</a></p>
<h3 id="written-by">Written By</h3>
<ul>
<li>Anirudh Dagar</li>
</ul>

                </div>
            </div>
        </div>
    </div>
</section>

<!-- Footer Section Start -->
<footer id="footer">
    <div class="container" id="footer-container">
        <div class="row content-justify-between">
            <div style="width: 100%;">
                <p class="copyright">
                    Contact Us
                </p>
            </div>
            <div class="col-md-7 col-12 text-lg-left text-md-left">
                <!-- Social Media -->
                <ul class="social">
                    
                    <li><a href="https://www.facebook.com/dsgiitr/"><i class="ion-social-facebook"></i></a></li>
                    
                    <li><a href="https://github.com/dsgiitr"><i class="ion-social-github"></i></a></li>
                    
                    <li><a href="https://www.linkedin.com/company/26638705/"><i class="ion-social-linkedin"></i></a></li>
                    
                    
                    <li style="float: right; color: #FFFFFF;"><i class="ion-closed-captioning"></i> DSG IITR</li>
                    
                </ul>
            </div>
            <div class="col-md-5 col-12 text-lg-left text-md-left location-foot">
                
                <div style="float: right; color: #FFFFFF;">
                    <i class="ion-ios-location" style="color: #000;"></i> New Sac Building, IIT Roorkee
                </div>
                
            </div>
        </div>
    </div>
    
    <script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });

  MathJax.Hub.Config({
  
  TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
</script>
</footer>
<!-- footer section end -->


<!-- jquery -->
<script src="/plugins/jQurey/jquery.min.js"></script>
<!-- Form Validation -->
<script src="/plugins/form-validation/jquery.form.js"></script>
<script src="/plugins/form-validation/jquery.validate.min.js"></script>
<!-- slick slider -->
<script src="/plugins/slick/slick.min.js"></script>
<!-- bootstrap js -->
<script src="/plugins/bootstrap/bootstrap.min.js"></script>
<!-- wow js -->
<script src="/plugins/wow-js/wow.min.js"></script>
<!-- slider js -->
<script src="/plugins/slider/slider.js"></script>
<!-- Fancybox -->
<script src="/plugins/facncybox/jquery.fancybox.js"></script>
<!-- template main js -->

<script src="/js/script.min.js"></script>
<!-- google analitycs -->
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', '', 'auto');
    ga('send', 'pageview');
</script>
<script type="text/javascript" src="/plugins/particlesjs/particles.min.js"></script>
<script type="text/javascript" src="/plugins/particlesjs/demo/js/app.js"></script></body>
</html>